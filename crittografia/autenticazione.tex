\chapter{Autenticazione}
\section{Introduzione}
I crittosistemi costruiti fino ad ora sono malleabili, quando riceviamo un messaggio vorremmo
essere sicuri che nessuno l'abbia modificato. Per farlo possiamo usare sistemi non malleabili
dove le modifiche non sono prevedibili, oppure aggiungere della ridondanza, aggiungendo
bit di parità o un codice ciclico di ridondanza.

Possedendo però un messaggio cifrato e la sua decifratura, o dalla chiave pubblica,
è possibile modificare un messaggio 
cifrato attraverso il non quadrato ricavato, alterando qualsiasi bit in maniera controllata, e 
quindi modificare in maniera controllata anche i codici di ridondanza.

Per garantire l'integrità e l'autenticità dei messaggi trasmessi, è fondamentale adottare sistemi di autenticazione avanzati. Uno di questi approcci consiste nell'utilizzare una funzione casuale condivisa tra mittente e destinatario.

Quando un mittente invia un messaggio, genera una sequenza di bit aggiuntiva chiamata
Message Authentication Code (\textit{MAC}). Questo \textit{MAC} viene ottenuto applicando una
funzione casuale precedentemente concordata al messaggio stesso. La casualità della
funzione è cruciale e deve essere condivisa solo tra le parti interessate, rimanendo
sconosciuta agli altri.

Il destinatario, una volta ricevuto il messaggio, applica la stessa funzione casuale
al messaggio ricevuto per calcolare un nuovo \textit{MAC}. Se il \textit{MAC} calcolato corrisponde a
quello ricevuto con il messaggio, ciò indica che il messaggio non è stato modificato
in modo controllato e l'autenticazione è riuscita.

L'uso di una funzione casuale impedisce a un potenziale aggressore di prevedere la
sequenza di bit aggiuntiva al messaggio. Inoltre, permette di verificare l'autenticità
del messaggio, poiché solo il mittente e il destinatario conoscono la funzione casuale
utilizzata.

Un possibile attaccante che dispone di un messaggio, non sarà in grado di produrre 
il codice di autenticazione corretto, poiché il risultato della applicazione di una funzione 
causale è una sequenza di bit casuale, e quindi non prevedibile e distinguibile.

\section{Funzioni pseudo-casuali}
Avendo imparato a generare bit pseudocasuali, siamo in grado di generare funzioni pseudo-casuali,
ovvero funzioni che non sono realmente casuali, ma sono generate da un seme, ma agli occhi 
di un osservatore esterno sono casuali.

Sia $\mathcal{U}_k$ l'insieme delle funzioni da $\{0,1\}^k$ a $\{0,1\}^k$, 
vogliamo scegliere $f$ appartenente a $\mathcal{U}_k$ in maniera casuale.

Possiamo generare una sequenza di bit pseudocasuali per generare l'indice di $f$ in 
una enumerazione di $\{0,1\}^k \to \{0,1\}^k$. Dalla teoria del calcolo combinatorio sappiamo
che la cardinalità di delle funzioni da $A$ a $B$ è $|B|^{|A|}$, quindi la cardinalità
di $\mathcal{U}_k$ è $\{0,1\}^{k\cdot \{0,1\}^k} = 2^{k\cdot 2^k}$.
Per denotare l'indice della funzione avremmo quindi bisogno di $\log_2(2^{k\cdot 2^k}) = k\cdot 2^k$ bit,
ovvero una quantità di bit esponenziale, cosa che non ci possiamo permettere.

Ci farebbe comodo denotare una funzione con $k$ bit, il problema è che con i nostri indici dovremmo 
denotare un insieme di funzioni minori dell'insieme delle funzioni in $\mathcal{U}_k$, dobbiamo 
quindi lavorare con un insieme $\mathcal{F}_k \subseteq \mathcal{U}_k$. Vogliamo comunque 
far in modo che chiunque non sia in grado di accorgersi che sia stata scelta una funzione
da un insieme più piccolo.

In un generatore di funzioni pseudocasuali, partiamo dall'idea che:
\begin{enumerate}
    \item Troviamo un insieme di funzioni
    $\mathcal{F}_k \subseteq \mathcal{U}_k$, tale che $|\mathcal{F}_k| = 2^k$; imponendo per definizione
    tale dimensione, siamo in grado di generare funzioni casuali avendo a disposizione $k$ bit;
    \item Esiste un algoritmo probabilistico polinomiale che calcola la funzione $(i,x) \mapsto f_i(x)$;
    \item Sia $\mathcal{D}\in \mathcal{PPT}$ un algoritmo che, su input $1^k$ (\textit{il 
    security parameter rappresentato in unario, nel valore, ovvero nel numero di bit che
    usiamo per rappresentare le nostre informazioni}), che interroga $f$ aribitrariamente,
    anche in maniera adattiva (\textit{scegliendo l'argomento su cui interrogare la funzione 
    $f$ anche sulla base dei risultati ottenuti dalle precedenti interrogazioni, ma sempre in 
    tempo polinomiale}). Siano $\mathcal{P}_k^{\mathcal{D}, \mathcal{U}}$ la probabilità che 
    $\mathcal{D}$ restituisca $1$ quando $f\in_R \mathcal{U}_k$ e $\mathcal{P}_k^{\mathcal{D}, \mathcal{F}}$
    la probabilità che $\mathcal{D}$ restituisca $1$ quando $f\in_R \mathcal{F}_k$, allora 
    \[
        \left| \mathcal{P}_k^{\mathcal{D}, \mathcal{U}} - \mathcal{P}_k^{\mathcal{D}, \mathcal{F}} \right| \leq k^{-\omega(1)}
    \]
\end{enumerate}
\subsection{Costruzione delle funzioni pseudo-casuali}
\subsubsection{Primo metodo}
Sia $\mathcal{G}$ un psudo random sequence generator (\texttt{PRSG}), ovvero un algoritmo che
genera una sequenza di bit pseudocasuali.
\begin{figure}[H]
    \centering
    \begin{tikzpicture}
      \node[draw, rectangle, minimum width=4cm, minimum height=3cm] (A) at (0,0) {$\mathcal{G}$};
      \draw[->] (-5, 0) -- (-2, 0) node[midway, above] {$i$};
      %freccia ondulata
      \draw[decorate, decoration={snake, amplitude=1mm}] (2, 0) -- (10, 0);
        \draw[-] (4, 0.2) -- (4, -0.2);
        \draw[-] (6, 0.2) -- (6, -0.2);
        \draw[-] (8, 0.2) -- (8, -0.2);
        \draw[-] (10, 0.2) -- (10, -0.2);

        %k bit
        \draw (3, 0.5) node {$k$};
        \draw (3, -0.5) node {$x$};
        \draw (5, 0.5) node {$k$};
        \draw (5, -0.5) node {$y$};
    \end{tikzpicture}
  \end{figure}
Su input $x$ generiamo $k$ bit e li restituiamo. Oltre a restituirli, ci ricordiamo che $x$ è 
associata ai primi $k$ bit generati dal \texttt{PRSG}. Sul successivo input $y$ se $y = x$
restituiamo il risultato precedente, altrimenti generiamo $k$ bit nuovi e li restituiamo.

Ogni volta che abbiamo un nuovo input, generiamo $k$ bit nuovi, altrimenti restituiamo il risultato
fornito in precedenza. 
Il problema di fondo abbastanza grosso è che una volta che abbiamo definito il seme $i$, 
la funzione è definita in maniera univoca da $i$? No, perché la funzione dipende dall'ordine 
in cui viene interrogata. Quindi passando prima $x$ e poi $y$ oppure prima $y$ e poi $x$
potremmo ottenere risultati diversi.

Ma agli occhi di chi osserva, siamo in presenza di una funzione casuale, se scegliamo un numero 
nuovo vediamo un risultato scelto uniformemente a caso, se scegliamo un numero già visto,
vediamo il risultato che abbiamo visto in precedenza.

Tuttavia questa costruzione non soddisfa la definizione che abbiamo dato, quindi possiamo 
far in modo che la definizione ammetta questa costruzione per la generazione di funzioni
pseudo-casuali. Ma per la costruzione che abbiamo in mente, ovvero per l'autenticazione di 
messaggi, questa costruzione non è adatta.
\[
  m, f(m)
\]
Chiunque non conosca $f$, e veda in $f(m)$ una sequenza casuale, 
e non sia in grado di calcolare $f(m')$ per $m' \neq m$. L'autenticazione di 
un messaggio $m'$ è possibile crearla solo con $f$.
\pseudocodeblock{
\begin{tikzpicture}
  \node[businessman, monitor, female, minimum size=2cm,label=below:{Alice}] (alice) {};
\end{tikzpicture}
\<\<
\begin{tikzpicture}
  \node[dave, monitor, mirrored, minimum size=2cm, label=below:{Bob}] (bob) {};
\end{tikzpicture}
\\[0.1\baselineskip][\hline] \\[-0.5\baselineskip]
\text{Dispone }i\<\<\text{Dispone }i \\
\<\sendmessageright*{x, f(x)} \\
\<\sendmessageleft*{y, f(y)} \\
}
Se le cose vanno esattamente come nel diagramma rappresentato, 
allora tutto va secondo i piani, poiché ogni agente riesce a verificare l'autenticità
di ogni messaggio.
\pseudocodeblock{
\begin{tikzpicture}
  \node[businessman, monitor, female, minimum size=2cm,label=below:{Alice}] (alice) {};
\end{tikzpicture}
\<\<
\begin{tikzpicture}
  \node[dave, monitor, mirrored, minimum size=2cm, label=below:{Bob}] (bob) {};
\end{tikzpicture}
\\[0.1\baselineskip][\hline] \\[-0.5\baselineskip]
\text{Dispone }i\<\<\text{Dispone }i \\
\<\sendmessagerightleft*{y, f(y)\qquad x, f(x)} \\
}
Scambiandosi i messaggi in maniera sincrona, poiché Alice utilizza il generatore 
e la prima volta che lo invoca, lo invoca su $x$, mentre Bob lo invoca su $y$,
Alice e Bob si trovano in una situazione in cui non sono in grado di verificare
poiché $f(x) = f(y)$.

Nel momento in cui la funzione $f$ dipende dall'ordine di interrogazione,
non è possibile distribuire la funzione $f$ a più agenti, e ci vorrebbe 
un oggetto centralizzato che distribuisce la funzione $f$ a tutti gli agenti.

Tale costruzione è utile in caso di generazione di funzioni pseudocasuali 
in cui l'utilizzo è locale, tuttavia la crescita di richieste fa si che 
la dimensione del database cresca e quindi allunghi i tempi di risposta e 
quindi ci si accorga della pseudocasualità nella generazione.
\subsubsection{Secondo metodo}
\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw, rectangle, minimum width=4cm, minimum height=3cm] (A) at (0,0) {$\mathcal{G}$};
    \draw[->] (-5, 0) -- (-2, 0) node[midway, above] {$i$};
    %freccia ondulata
    \draw[decorate, decoration={snake, amplitude=1mm}] (2, 0) -- (10, 0);
      \draw[-] (4, 0.2) -- (4, -0.2);
      \draw[-] (6, 0.2) -- (6, -0.2);
      \draw[-] (8, 0.2) -- (8, -0.2);
      \draw[-] (10, 0.2) -- (10, -0.2);

      %k bit
      \draw (3, 0.5) node {$n$};
      \draw (3, -0.5) node {$0$};
      \draw (5, 0.5) node {$n$};
      \draw (5, -0.5) node {$1$};
      \draw (7, 0.5) node {$n$};
      \draw (7, -0.5) node {$\dots$};
      \draw (9, 0.5) node {$n$};
      \draw (9, -0.5) node {$\dots$};
  \end{tikzpicture}
\end{figure}
Dove $f_i$ è definita come l'\textit{x-esimo gruppo di $n$ bit restituito da $\mathcal{G}$}.
In questo caso l'insieme $f_i$ è definito in maniera univoca. Per ogni $i$ c'è 
una funzione $f_i$ definita in maniera univoca, quindi l'insieme $\mathcal{F}_k$ è 
l'insieme delle funzioni $f_i$ definite nella maniera appena descritta.

Il problema sorge nella condizione che indica che esiste un algoritmo probabilistico
polinomiale tale che $(i,x) \mapsto f_i(x)$. Sia $x=1...1 = 2^{k-1} - 1$, per come è 
definito il generatore, per farlo dobbiamo generare tutti i numeri da $0$ a $2^{k-1} - 1$,
quindi i bit totali da generare sono $k \cdot 2^{k-1}$, quindi il tempo di esecuzione
non è polinomiale.

\subsubsection{Terzo metodo}

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw, rectangle, minimum width=4cm, minimum height=3cm] (A) at (0,0) {$\mathcal{G}$};
    \draw[->] (-5, 0) -- (-2, 0) node[midway, above] {$i \oplus x$};
    %freccia ondulata
    \draw[decorate, decoration={snake, amplitude=1mm}] (2, 0) -- (4, 0);
      \draw[-] (4, 0.2) -- (4, -0.2);

      %k bit
      \draw (3, 0.5) node {$k$};
      
  \end{tikzpicture}
\end{figure}
Come seme usiamo $i \oplus x$, e prendiamo i primi $k$ bit del risultato. Quindi 
$f_i(x)$ è definita come i primi $k$ bit di $\mathcal{G}(i \oplus x)$.
Sappiamo che ogni 
indice $i$ determina una funzione $f_i$ definita in maniera univoca.
Inoltre l'algoritmo che genera $f_i$ è polinomiale, poiché per generare $f_i$
è sufficiente eseguire lo \texttt{XOR} tra $i$ e $x$ e, che è un'operazione polinomiale,
e poi generare con il generatore $\mathcal{G}$ i primi $k$ bit del risultato, e sappiamo che 
$\mathcal{G}$ è un algoritmo polinomiale.

Dobbiamo capire se esiste distinguisher in grado di distinguere $f_i$ da una funzione
casuale. Supponiamo che esista $\mathcal{D}$ tale per cui 
$\left| \mathcal{P}_k^{\mathcal{D}, \mathcal{U}} - \mathcal{P}_k^{\mathcal{D}, \mathcal{F}}
\right| > k^{-\omega(1)}$, vorremmo trasformare $\mathcal{D}$ in un algoritmo
che viola la correttezza del generatore $\mathcal{G}$.

Per farlo dobbiamo assicurarci che il distinguisher $\mathcal{D}$ stia facendo 
implicitamente su $\mathcal{G}$, tutti esperimenti che siano compatibili con quello 
che abbiamo detto per definire la correttezza di $\mathcal{G}$.

Nel caso specifico il distinguisher $\mathcal{D}$ può scegliere 
valori distinti di $x$, ma il generatore $\mathcal{G}$ conosce tali 
valori $x_1, x_2, \dots, x_n$, prendendo lo \texttt{XOR} di uno dei 
due valori in input a $\mathcal{G}$, otteniamo lo \texttt{XOR} 
del seme usato in $\mathcal{G}$, allora il distinguisher è in grado 
di osservare l'output di $\mathcal{G}$ su due semi di cui è nota 
la differenza.

Se interroghiamo $f(0) = a$ e $f(1^k)= b$, sappiamo che il seme
usato per generare $a$ è esattamente il complemento del seme usato 
per generare $b$. In generale se $f(x) = a'$ e $f(y)=a''$, allora
sappiamo che \texttt{XOR} dei semi usati per generare $a'$ e $a''$
è esattamente $x \oplus y$. Gli esperimenti che il distinguisher
riesce a fare implicitamente su $\mathcal{G}$ sono esperimenti 
che il distinguisher che abbiamo usato per definire la correttezza
su $\mathcal{G}$ non è in grado di fare.
Quindi il distinguisher che sta lavorando sulle funzioni pseudocasuali 
è più potente del distinguisher ammesso nella definizione di
correttezza di $\mathcal{G}$, quindi abbiamo una contraddizione.

In questo caso i casi possono essere due:
\begin{itemize}
  \item Abbiamo definito un generatore troppo debole, poiché 
  abbiamo bisogno di una definizione più forte, che ammetta 
  esperimenti di questo tipo;
  \item Possiamo far vedere che se abbiamo un generatore di bit 
  pseudocasuali, allora tale generatore resiste ad attacchi di questo
  tipo.
\end{itemize}
In questo caso è possibile costruire un generatore di bit pseudocasuali
$\mathcal{G}$ e che se usato in questo contesto permette di costruire un 
distinguisher $\mathcal{D}$.

Incapsuliamo il generatore in un generatore più grande $\mathcal{G}'$, che prende in 
input $i_0, i_1, \dots, i_{k-1}$. Se $i_0 = 0$ allora si inviano 
$i_1, i_2, \dots, i_{k-1}$ al generatore $\mathcal{G}$, altrimenti
si invia $\overline{i_1}, \overline{i_2}, \dots, \overline{i_{k-1}}$
al generatore $\mathcal{G}$.
Scegliendo un seme a caso usiamo $\mathcal{G}$ con un seme a caso,
poiché il complemento di una sequenza di bit casuali è sempre una 
sequenza casuale, quindi stiamo generando una sequenza di bit casuali con 
security parameter $k-1$.

Il nuovo generatore $\mathcal{G}'$ è un generatore di bit pseudocasuali
che soddisfa la definizione di correttezza. L'output di $\mathcal{G}'$
è effettivamente un seme distribuito 
uniformemente tra tutti i possibili semi, e quindi si comporta 
come $\mathcal{G}$. Tuttavia usando tale oggetto nel contesto 
riportato sopra, scopriamo che $f(0) = f(1^k)$. Il distinguisher 
$\mathcal{D}$ in questo caso riusciamo quindi a costruirlo facilmente,
poiché basta che controlli se $f(0) = f(1^k)$, e se questo è vero
allora $\mathcal{D}$ restituisce $1$, altrimenti restituisce $0$. Di fronte 
ad una funzione pseudocasuale risponderà sempre $1$, di fronte ad 
una funzione casuale risponderà $1$ solamente quando $f(0) = f(1^k)$,
ma tale uguaglianza avviene con probabilità $2^{-k}$, perché 
è la probabilità che due sequenze di $k$ bit siamo uguali, la differenza 
essendo enorme distingue con probabilità $1$.

La soluzione alla quale vogliamo ambire è una soluzione che cercherà 
di evitare il problema.
\subsubsection{Quarto metodo}
Torniamo al secondo metodo, dove $f_i(x)$ è l'$x-esimo$ gruppo di 
$\mathcal{G}$, eravamo rimasti al fatto che non riuscissimo a calcolare 
$f_i(x)$ in tempo polinomiale. Per poter calcolare $f_i(x)$ in tempo
polinomiale, usiamo un generatore di Blum-Blum-Shub, lavorando con il 
logaritmo discreto non siamo in grado di calcolare elementi molto distanti,
ma se dobbiamo calcolare $f_i(2^k - 1)$ servono solamente i bit dalla 
posizione $k \cdot (2^k - 1) - 1$ a $k \cdot k \cdot 2^k$.

\begin{figure}[H]
  \centering
  \begin{tikzpicture}
    \node[draw, rectangle, minimum width=4cm, minimum height=3cm] (A) at (0,0) {$\texttt{BBS}$};
    \draw[->] (-5, 0) -- (-2, 0) node[midway, above] {$i$};
    %freccia ondulata
    \draw[decorate, decoration={snake, amplitude=1mm}] (2, 0) -- (10, 0);
      \draw[-] (4, 0.2) -- (4, -0.2);
      \draw[-] (6, 0.2) -- (6, -0.2);
      \draw[-] (8, 0.2) -- (8, -0.2);
      \draw[-] (10, 0.2) -- (10, -0.2);

      %k bit
      \draw (3, 0.5) node {$n$};
      \draw (3, -0.5) node {$0$};
      \draw (5, 0.5) node {$n$};
      \draw (5, -0.5) node {$1$};
      \draw (7, 0.5) node {$n$};
      \draw (7, -0.5) node {$\dots$};
      \draw (9, 0.5) node {$n$};
      \draw (9, -0.5) node {$2^{k-1}$};
  \end{tikzpicture}
\end{figure}

Per calcolare tali bit, avendo a disposizione il seme $i$, per 
calcolare il bit $k \cdot (2^k - 1) - 1$ dobbiamo calcolare
$i^{k \cdot (2^k - 1) - 1}$, che è abbastanza complicato da calcolare.
Tuttavia gli esponenti lavorano in modulo $\phi(n)$ e una volta 
calcolato l'esponente possiamo lavorare in modulo $n$, quindi
possiamo calcolare $i^{(k \cdot (2^k - 1) - 1)\mod \phi(n)} \mod n$,
in tempo polinomiale $k^3$ dove $k$ è il numero di bit.
Di conseguenza l'oggetto è calcolabile in tempo polinomiale,
quindi abbiamo un algoritmo \texttt{PPT} che è in grado di calcolare 
$f_i(x)$.

Questa operazione non è possibile con tutti i generatori, il 
generatore di Blum-Blum-Shub lavora in un gruppo di cardinalità 
finita ed ha una struttura particolare che permette di fare
questo tipo di operazioni.

Dobbiamo vedere se tale oggetto soddisfa la terza proprietà di un 
oggetto pseudocasuale, ovvero che sia indistinguibile da una funzione
realmente casuale. Il distinguisher $\mathcal{D}$ interroga 
la funzione $f$ e nell'interrogare la funzione $f$ sta implicitamente 
facendo degli esperimenti su $\mathcal{G}$, ma gli esperimenti possono essere 
fatti in tempo polinomiale, quindi un numero esponenziale di bit non 
può essere vista dal distinguisher. Quindi con il generatore di funzioni 
pseudocasuali siamo in grado di vedere dei bit che il distinguisher non è 
in grado di vedere.

In questa situazione però non siamo riusciti a costruire un controesempio.

\subsubsection{Quinto metodo}
Usiamo l'indice della funzione $i$ di $k$ bit, come seme e di base usiamo un 
generatore pseudocasuale $\mathcal{G}$, per generare $2k$ bit,
$\mathcal{G}(s)[0,\dots,k-1]$ ovvero $s_0$ e lo stesso per $\mathcal{G}(s)[k,\dots,2k-1]$
ovvero $s_1$. e ripetiamo ricorsivamente il procedimento generando $s_{00}, s_{01}, s_{10}$
e $s_{11}$, che sono rispettivamente $s_0[0,\dots,k-1], s_0[k,\dots,2k-1], s_1[0,\dots,k-1]$.
\begin{figure}[H]
  \centering
  \begin{tikzpicture}[level distance=1.5cm,
  level 1/.style={sibling distance=3cm},
  level 2/.style={sibling distance=1.5cm}]
    \node {$s$}
      child { 
        node {$s_0$}
        child {
          node {$s_{00}$}
        }
        child {
          node {$s_{01}$}
        }
      }
      child {
        node {$s_1$}
        child {
          node {$s_{10}$}
        }
        child {
          node {$s_{11}$}
        }
      };
  \end{tikzpicture}
\end{figure}
Scendendo nell'albero, arriviamo al seme indicizzato da $x$, ovvero
$s_x$, che è un seme di $k$ bit, che è il risultato della funzione
$f_i(x)$. Ovviamente questo albero ha $2^k$ nodi e le foglie rappresentano i 
valori delle funzioni sui diversi argomenti a partire da $s$ in radice,
quindi la funzione $f_s(x)$ ovvero $f_i(x)$ è ben definita.

Per calcolare tale funzione in tempo polinomiale, dobbiamo calcolare
calcolare solamente un cammino dell'albero, quindi il tempo di calcolo
è polinomiale. Infatti per calcolare un nodo dell'albero nel caso pessimo 
calcoliamo $2k$ bit per $k$ volte a cui si moltiplica il tempo di generazione 
di $2k$ bit dal generatore di Blum-Blum-Shub, che esegue un elevamento al 
quadrato per ogni bit, quindi il tempo di calcolo è
$\theta(k^4)$.

Dobbiamo verificare che non esista un distinguisher $\mathcal{D}$ che
sia in grado di distinguere la funzione $f_s(x)$ da una funzione
realmente casuale. Creiamo un distinguisher $\mathcal{D}$ che 
interroga la funzione $f_s(x)$; implicitamente sta facendo degli esperimenti
sul generatore $\mathcal{G}$, in maniera nidificata.
Guardando l'albero a livelli, un generatore pseudocasuale trasforma una 
certa quantità di casualità in una quantità di casualità diversa.

Definiamo gli alberi:
\begin{align*}
  \begin{array}{r c lllllllll}
  \mathcal{T}_0 & = & s^1 &\dots &s^{i-1} & s^i &s^{i+1} & s^{i+2} &\dots &s^l \\
  \mathcal{T}_{l}& = & r^1 &\dots &r^{i-1} & r^i &r^{i+1} & r^{i+2} &\dots &r^l \\
  \end{array}
\end{align*}
Dove $\mathcal{T}_0$ è l'albero che rappresenta esattamente l'albero definito 
per la generazione di funzioni pseudocasuali, mentre $\mathcal{T}_l$ corrispondente ad una funzione 
casuale campionata uniformemente dell'insieme $\mathcal{U}_k$.

Il distinguisher secondo la nostra ipotesi vede la differenza tra un albero 
costruito secondo la prima tecnica e un albero costruito secondo la seconda.

\[
  \big|\mathcal{P}_k^{\mathcal{D}, \mathcal{G}} - \mathcal{P}_k^{\mathcal{D}, \mathcal{U}}\big| > k^{-c}
  \qquad\text{quindi}\qquad
  \big|\mathcal{P}(0) - \mathcal{P}(k)\big| > k^{-c}
\]

In questo caso costruiamo tutti gli alberi intermedi dove 
per ogni livello $i= 0, \dots, k$ definiamo l'albero $\mathcal{T}_i$ tale che:
\begin{itemize}
  \item I nodi dei livelli $0, \dots, i$ sono tutti casuali;
  \item I nodi dei livelli $i+1, \dots, k$ sono tutti pseudocasuali.
\end{itemize}
Con la solita tecnica di interpolazione, possiamo affermare che se il distinguisher è
in grado di rilevare la differenza tra un albero costruito secondo lo schema $\mathcal{T}_0$
e un albero costruito secondo lo schema $\mathcal{T}_k$, allora può individuare la differenza
tra livelli adiacenti mediante interpolazione. Poiché due livelli adiacenti differiscono solamente
per un livello specifico, otteniamo due alberi distinti che si differenziano solo per quel livello
particolare. Pertanto, calcolando $f_s(x)$ risulterebbe equivalente a retrocedere al nodo $i$-esimo
dell'albero $\mathcal{T}$ e osservarlo casualmente in un caso e pseudocasualmente nell'altro, con un
seme generato al livello precedente in maniera veramente casuale. L'esperimento di calcolare $f_s(x)$
è quindi il classico test su un generatore di bit pseudocasuali.
\[
  \exists i \in \{0, \dots, k-1\} \quad \big| \mathcal{P}(i) - \mathcal{P}(i+1) \big| > k^{-c'}
\]
Effettuando un esperimento su $f_s(y)$ che proviene dall'istanza dello stesso nodo $i$-esimo dell'albero
$\mathcal{T}$, possiamo considerarlo come un'istanza dello stesso esperimento, ossia un esperimento sui
bit di livello $i$ casuali o pseudocasuali. Se l'esperimento è condotto su $f_s(z)$ proveniente da una
nuova istanza di un nodo $i$-esimo dell'albero $\mathcal{T}$, allora può essere considerato un nuovo
esperimento indipendente, consentendo la realizzazione di più esperimenti indipendenti.

Se la probabilità di successo con un singolo esperimento è inferiore a qualsiasi polinomio,
la probabilità di successo
con un numero polinomiale di esperimenti indipendenti è comunque inferiore a qualsiasi polinomio.

Di conseguenza un esistenza di un attaccante al generatore di funzioni si traduce 
in un attaccante al generatore di bit pseudocasuali $\mathcal{G}$, quindi 
il distinguisher non esiste se assumiamo  che il generatore di partenza soddisfi 
la definizione.

\section{Autenticazione}
Ci sono due o più agenti che si scambiano messaggi, non necessariamente orientati alla segretezza 
dei messaggi, ma vogliono essere sicuri che i messaggi siano creati solo da loro e non da altri.

Una possibilità è quella di scegliere una funzione pseudocasuale $f$ da condividere tra gli agenti, 
la funzione può essere generata con un qualsiasi schema, per esempio lo schema precedente che sfrutta 
l'utilizzo di un seme, e questo seme viene scambiato tra gli agenti attraverso un canale sicuro.
Ad ogni messaggio $m$ si aggiunge il valore $f(m)$, spedendo quindi la coppia $(m, f(m))$, in altri 
termini $f(m)$ è l'autenticazione di $m$, non mandando quindi solo il messaggio $m$, ma anche la 
sequenza di bit che è l'autenticazione di $m$.

La funzione è pseudocasuale, di conseguenza chiunque non conosca il seme di partenza vede di fianco 
ad ogni messaggio una sequenza di $k$ bit scelta uniformemente a tra le sequenze di $k$ bit. Qualunque 
agente che conosce il seme può calcolare autonomamente $f(m)$ e confrontarlo con il secondo elemento della 
coppia, se sono uguali allora il messaggio è autentico, altrimenti non è autentico.
\subsection{Forger}
Sia $\mathcal{F}$ un \textbf{forger}, ovvero un algoritmo probabilistico polinomiale che interroga $f$ su una 
sequenza di messaggi $m_1, m_2, \dots, m_l$, anche in modo adattivo e alla fine restituisce una coppia
$(m, \sigma)$, diciamo che $\mathcal{F}$ ha successo se $f(m) = \sigma$ e $\forall i \, m \neq m_i$, quindi 
restituisce una coppia $(m, \sigma)$ dove $m$ non è mai stato interrogato e $\sigma$ è l'autenticazione di $m$.

\[
  \forall \mathcal{F} \in \texttt{PPT} \quad \mathcal{P}
  \big[ \text{Succ}(\mathcal{F}) = 1 \big] \leq k^{-\omega(1)}
\]
\subsection{Autenticare messaggi lunghi}
L'idea è quella di dividere il messaggio in blocchi di lunghezza $k$, quindi $m = m_1, \dots, m_l$, possiamo 
cercare di creare l'autenticazione applicando la funzione $f$ a ogni blocco, quindi $f(m_1), \dots, f(m_l)$ e 
definire il messaggio $m$ come:
\[
  m = m_1 \oplus f(m_1) \oplus f(m_2) \oplus \dots \oplus f(m_l)
\]
Il problema è che il forger in questo caso può combinare i blocchi in modo diverso, quindi può creare un
messaggio $m'$ che è diverso da $m$, ma che ha la stessa autenticazione.
Infatti chiedendo la coppia $(m_1m_2, f(m_1 m_2))$, la coppia $(m_2 m_1, f(m_2 m_1))$ è una coppia
autentica.

Costruire un messaggio autenticato senza interrogare la funzione $f$ in questo caso è molto semplice, 
infatti costruendo la coppia $(m_1 m_1, f(m_1 m_1))$, lo \texttt{XOR} di due messaggi uguali è sempre $0$,
e dal punto di vista della definizione abbiamo trovato il forger, quindi abbiamo la necessità di utilizzare 
un meccanismo più complesso per autenticare messaggi lunghi vietando inoltre lo scambio dei blocchi.
Per farlo la posizione di ogni singolo blocco deve avere un impatto sulla funzione $f$.
\[
  f(m) = f(\langle 1 \rangle m_1) \oplus f(\langle 2 \rangle m_2) \oplus
  \dots \oplus f(\langle l \rangle m_l)
\]
Dove $\langle i \rangle$ è una stringa di pochi bit che rappresenta la posizione del blocco $m_i$.
Purtroppo però anche con questo sistema il forger può creare un messaggio autentico in modo semplice:

\begin{align*}
  \begin{array}{r c l}
    f(m_1 m_2) & = & f(\langle 1 \rangle m_1) \oplus f(\langle 2 \rangle m_2) \\
    f(m_1' m_2) & = & f(\langle 1 \rangle m_1') \oplus f(\langle 2 \rangle m_2) \\
    f(m_1 m_2') & = & f(\langle 1 \rangle m_1) \oplus f(\langle 2 \rangle m_2') \\
    \hline
    f(m_1' m_2') & = & f(\langle 1 \rangle m_1') \oplus f(\langle 2 \rangle m_2') \\
  \end{array}
\end{align*}

L'idea per risolvere il problema potrebbe essere l'applicazione nidificata della funzione $f$
in stile cypher block chaining, ovvero:
\[
  f'(m_1\dots m_l) =   f(m_l \oplus \dots \oplus f(m_3 \oplus f(m_2 \oplus f(m_1))))
\]
Questo sistema è dimostrabilmente sicuro; difatti, ciò che viene realizzato è
la costruzione di una nuova funzione $f' : \{0, 1\}^{kl} \to \{0, 1\}^k$, partendo
da una funzione pseudocasuale di $k$ bit in $k$ bit, che incrementa la dimensione dell'input.
Possiamo concepire questo concetto come un'estensione dell'idea di generazione di funzioni pseudocasuali.
Supponiamo di avere una funzione scelta in modo uniforme tra le funzioni da $\{0, 1\}^k$ a $\{0, 1\}^k$,
oppure una funzione da $kl$ bit a $k$ bit, selezionata da un insieme di dimensione più ridotta, poiché
dipende dallo stesso seme utilizzato per $f$. Il nostro obiettivo è affermare che questo sistema è
sicuro nel senso che non esiste alcun algoritmo probabilistico polinomiale in grado di distinguere
una funzione pseudocasuale da una funzione casuale.

L'eventuale forger può essere convertito in un distinguisher; pertanto, affermare che si tratta
di un sistema di autenticazione o di una funzione pseudocasuale da $kl$ bit a $k$ bit è equivalente, 
quindi l'esistenza di un forger implica l'esistenza di un distinguisher, e viceversa.

Dimostriamo quindi che la costruzione della funzione $f'$ è una costruzione di una funzione pseudocasuale
da $kl$ bit a $k$ bit, partendo da una funzione pseudocasuale da $k$ bit a $k$ bit, e dimostriamo che è
una funzione pseudocasuale nel senso delle definizioni date sulle funzioni pseudocasuali, ovvero 
non esiste alcun algoritmo probabilistico polinomiale in grado di distinguere una funzione pseudocasuale
da una funzione casuale.

Per farlo costruiamo $\mathcal{F}_i (m_1, \dots, m_i)$ prende i primi $i$ blocchi del messaggio e applica 
la funzione $f$ pseudocasuale a questi blocchi e per i successivi $l - i$ blocchi applica la funzione
$r$ casuale, quindi:

\[
  \mathcal{F}(m_1\dots m_l) =   r(m_l \oplus \dots \oplus r(m_{i+1} \oplus f(m_i \oplus \dots \oplus f(m_3 \oplus
  f(m_2 \oplus f(m_1))))))
\]
A questo punto, sapendo che $f_0$ è sempre casuale in tutti i punti e $f_1$ è pseudocasuale in tutti i punti, 
sapendo distinguere i due estremi possiamo, per interpolazione, distinguere anche i punti intermedi.
Sappiamo che $\mathcal{P}(i)$ è la probabilità che il distinguisher restituisca $1$ se la funzione 
di autenticazione è la funzione $\mathcal{F}_i$, allora:
\[
  \big| \mathcal{P}(i) - \mathcal{P}(i+1) \big| > k^{-c}
\]
Quindi distinguere sul livello $i$-esimo e il livello $i+1$-esimo si traduce in una distinzione
nell'utilizzo di una funzione pseudocasuale e una funzione casuale, quindi:
\[
  \exists i \in \{0, \dots, k-1\} \quad \big| \mathcal{P}(i) - \mathcal{P}(i+1) \big| > k^{-c'}
\]
Diventando quindi un distinguisher per la funzione pseudocasuale $f$.
\subsection{Problema della non ripudiabilità}
Vorremmo avere a disposizione un sistema che permetta di autenticare un messaggio, in modo tale che
il mittente non possa negare di averlo inviato, poiché con le tecniche utilizzate fino ad ora i messaggi 
potrebbero essere stati creati da chiunque. Tale problema è legato al concetto di firma digitale, chi firma 
il messaggio non può negare di averlo firmato, in quanto la firma è univoca e non può essere riprodotta da
nessun altro. 

In sostanza, solo un agente può firmare un messaggio, e tutti possono verificare la firma. Chi può verificare 
non può firmare, nel momento in cui la firma è stata apposta non può essere contestata.
Devono quindi esistere due chiavi, una chiave privata per firmare e una chiave pubblica per verificare, e 
dalla chiave pubblica non deve essere possibile risalire alla chiave privata.

\subsubsection{\texttt{RSA} nella firma digitale}
L'algoritmo \texttt{RSA} può essere utilizzato per la firma digitale, in quanto è un algoritmo a
chiave pubblica e privata, e la chiave pubblica non può essere utilizzata per risalire alla chiave privata.

In \texttt{RSA} classico, il messaggio da criptare si eleva alla potenza $e$ e si prende il modulo $n$, e 
per decriptare si eleva alla potenza $d$ e si prende il modulo $n$. Per il teorema di Eulero, $n$ elevato 
alla cardinalità del gruppo fornisce l'unità, quindi $m^{\phi(n)} \equiv 1 \mod n$, quindi $m^{k\phi(n) + 1}
\equiv m \mod n$.

Per firmare un messaggio $m$ si calcola $m^d \mod n$, e per verificare la firma si calcola $(m^d)^e \mod n$,
che è uguale a $m$. Solamente chi possiede la chiave privata può firmare, mentre la verifica può essere
effettuata da chiunque.
\[
  (m^d)^e \equiv m^{de} \equiv m^{k\phi(n) + 1} \equiv m \mod n
\]
\subsection{Definizione di sistema di firma digitale}
Un sistema di firma digitale è una tripla di algoritmi $(\mathsf{Gen}, \mathsf{Sign}, \mathsf{Ver})$ probabilistici 
polinomiali.
\begin{itemize}
  \item $\mathcal{G}$ è un algoritmo probabilistico polinomiale che prende in input $1^n$ (\textit{poiché 
  l'algoritmo deve essere polinomiale nel valore del security parameter, ovvero il numero di bit che usiamo 
  per rappresentare le nostre chiavi, visto che sulle macchine di Turing la dimensione del problema è 
  pari al numero di celle che usiamo nel nastro di input}) che produce una coppia di chiavi $(p_k, s_k)$;
  \item $\mathcal{S}$ è un algoritmo probabilistico polinomiale che prende in input una chiave privata $s_k$
  e il messaggio $m$ e produce una firma $\sigma$;
  \item $\mathcal{V}$ è un algoritmo probabilistico polinomiale che prende in input una chiave pubblica $p_k$,
  e la firma $\sigma$ e restituisce $1$ se la firma è valida, $0$ altrimenti.
\end{itemize}
La probabilità di verificare una firma costruito secondo lo schema di firma digitale è $1$.
\[
  \forall \mathcal{P}\left[ \mathcal{V}(p_k, \mathcal{S}(s_k, m)) = 1 \right] = 1
\]
Si parla di probabilità perché l'algoritmo di verifica potrebbe essere un algoritmo probabilistico polinomiale,
e di conseguenza sbagliare, ma la probabilità che questo accada è $0$.

Sia $\mathcal{F} \in \texttt{PPT}$ un algoritmo che chiede la firma di messaggi $m_0, m_1, \dots, m_l$, anche 
in modo adattivo, e che produce una coppia $(m, \sigma)$, dove $m$ è il messaggio che viene firmato e $\sigma$ 
ed $\mathcal{F}$ ha successo se $\mathcal{V}(p_k, \sigma) = 1$ e $m \notin \{m_0, m_1, \dots, m_l\}$.
\[
  \forall \mathcal{F} \in \texttt{PPT} \qquad \mathcal{P}\left[ \mathcal{F} \text{ ha successo} \right] 
  \leq k^{-\omega(1)}
\]
Se $\mathcal{F}$ non riesce a produrre una firma falsa avendo a disposizione la chiave pubblica, è 
evidente che chiunque abbia la chiave pubblica non può produrre firme; non è possibile ricavare la chiave privata, 
perché l'unico modo che conosciamo per produrre una firma è mediante l'algoritmo $\mathcal{S}$, che prende in 
input la chiave privata e di conseguenza un crittosistema di firma digitale che soddisfa queste definizioni 
è un sistema che soddisfa la proprietà di non ripudiabilità.

\texttt{RSA} però non è un buon sistema di firma digitale, nel senso che non soddisfa la definizione data, 
infatti non è vero che ogni forger ha una probabilità di successo trascurabile, infatti è possibile forgiare
messaggi, dati $(m_1, m_1^d)$ e $(m_2, m_2^d)$, creando un nuovo messaggio $(m_1m_2, (m_1m_2)^d)$. Chiaro che 
inserendo sufficiente ridondanza ai messaggi in modo tale che molto difficilmente $m_1m_2$ sia un messaggio significativo 
questi attacchi non producono nulla.

\subsection{Firma di messaggi lunghi}
L'idea alla base è quella dell'utilizzo di \textbf{funzioni hash} crittograficamente sicure, quindi 
il messaggio $\sigma$ viene calcolato come $\sigma = H(m)^d$. Il motivo per cui viene firmato l'hash 
di un messaggio è per poter firmare messaggi lunghi, evitando quindi di utilizzare firme lunghe tanto 
quanto il messaggio originale. Utilizzando questa metodologia cosa succede se dati due messaggi 
$m_1$ e $m_2$, $H(m_1) = H(m_2)$? In questo caso è possibile forgiare un messaggio, infatti 
chiedendo la firma del messaggio $m_1$, è possibile forgiare la firma del messaggio $m_2$ utilizzando 
la firma del messaggio $m_1$.

Per la natura intrinseca delle funzioni hash, tali funzioni hanno collisioni, quindi è necessario
utilizzare delle funzioni hash crittograficamente sicure, ovvero funzioni hash collision resistant, 
su cui è difficile trovare collisioni. Quindi è computazionalmente difficile trovare due messaggi
$m_1$ e $m_2$ tali che $H(m_1) = H(m_2)$.
\begin{tcolorbox}[title = Funzione collision resistant]
  Una funzione $H$ è \textbf{collision resistant} se per ogni algoritmo $\mathcal{A}$ che lavora in tempo 
  polinomiale, la probabilità che $\mathcal{A}$ produca una coppia $(m_1, m_2)$ tale che $H(m_1) = H(m_2)$ 
  è trascurabile, più piccola di qualsiasi polinomio.
\end{tcolorbox}
degli esempi di funzioni hash collision resistant possono essere \texttt{MD5}, \texttt{SHA-1}, \texttt{SHA-2}.
\texttt{SHA-2} al momento è considerata lo stato dell'arte, ma è possibile che in futuro vengano 
trovati attacchi che permettono di trovare collisioni in \texttt{SHA-2}.

Utilizzando funzioni hash collision resistant all'interno di \texttt{RSA} per firmare messaggi, 
allora il sistema di firma digitale è sicuro, ovvero soddisfa la definizione data in precedenza, poiché 
non siamo in grado di produrre la firma di un messaggio $m_1 \cdot m_2$ a partire dalla firma di $m_1$
e $m_2$, perché l'hash di $m_1 \cdot m_2$ è diverso dall'hash di $m_1$ e $m_2$.

\subsection{Funzioni hash one way}
Una funzione hash $H$ è one way se dato $x$ è difficile trovare un qualsiasi $m$ tale che $H(m) = x$,
ovvero facile da calcolare, ma difficile da invertire. In una funzione iniettiva, dove ogni elemento
dell'immagine (\textit{codominio}) ha un unico elemento dell'insieme di partenza, quindi 
trovare l'inversa è semplice, siccome $f: A \rightarrow B$ è iniettiva
allora $f^{-1}: B \rightarrow A$ è definita. Per invertire una funzione hash, che non è iniettiva,
è necessario utilizzare tecniche di \textbf{brute force}, ovvero provare tutti i possibili input
e trovare un qualsiasi input che produce l'hash $x$.

\begin{proposizione}
  Se $H$ è una funzione collision resistant, allora $H$ è anche una funzione one way.
\end{proposizione}
\begin{proof}
  Supponiamo che $H$ non sia one way, mostriamo quindi che $H$ non è collision resistant. 

  Sia $m$ un messaggio casuale e calcoliamo $x = H(m)$, quindi $x$ è un valore casuale che 
  viene dato in input alla macchina che inverte la funzione hash e che produrrà un messaggio
  $m'$ tale che $H(m') = x$.

  \begin{figure}[H]
    \centering
    \begin{tikzpicture}
      \node[draw, rectangle, minimum width=4cm, minimum height=3cm] (A) at (0,0) {$H^{-1}$};
      \draw[->] (-5, 0) -- (-2, 0) node[midway, above] {$x$};
      %freccia ondulata
      \draw[->] (2, 0) -- (5, 0);
      \draw (3, 0.5) node {$m_1$};
    \end{tikzpicture}
  \end{figure}

  Con il fatto di aver scelto $m$ in modo casuale, la probabilità che $H^{-1}$ restituisca lo stesso 
  messaggio $m$ è trascurabile, quindi con probabilità $1$ abbiamo trovato una collisione.
\end{proof}
\section{Blind signature}
\textbf{Blind signature} è un protocollo che permette di firmare un messaggio senza che il firmatario 
sappia cosa sta firmando. Esiste un messaggio $m$ che l'agente $B$ deve firmare e $B$ non può 
conoscere $m$. L'agente $A$ che ha bisogno della firma sceglie un elemento $b$ casuale appartenente 
al gruppo $\mathbb{Z}_n^*$ chiamato \textbf{blinding factor} e calcola $m \cdot b^e$, dove 
$e$ è la chiave pubblica di $B$, e ne chiede 
la firma l'agente $B$ calcola la firma $\sigma = (m \cdot b^e)^d = m^d \cdot b$ e 
comunica $\sigma$ ad $A$. In questo caso 
non si utilizza la funzione hash essendo fondamentale l'utilizzo della struttura dei messaggi,
quindi bisognerà utilizzare tecniche alternative, come la ridondanza 
dei messaggi, per evitare gli attacchi visti precedentemente.
L'agente $A$ calcola quindi $\sigma' = \sigma \cdot b^{-1}$ ottenendo $m, \sigma'$, quindi
$\sigma'$ è la firma del messaggio $m$.

\pseudocodeblock{
\begin{tikzpicture}
  \node[businessman, monitor, female, minimum size=2cm,label=below:{Alice}] (alice) {};
\end{tikzpicture}
\<\<
\begin{tikzpicture}
  \node[dave, monitor, mirrored, minimum size=2cm, label=below:{Bob}] (bob) {};
\end{tikzpicture}
\\[0.1\baselineskip][\hline] \\[-0.5\baselineskip]
\text{Sceglie }x \in_R \mathbb{Z}_n^*\<\< \\
\<\sendmessageright*{m \cdot b^e} \\
\<\sendmessageleft*{\sigma = (m \cdot b^e)^d} \\
\text{Produce $\sigma'$ dove }\sigma' = \sigma \cdot b^{-1} = m^d\<\<\\
}
$A$ interagendo con $B$ riesce a far produrre una firma per il messaggio $m$ senza che $B$ sappia
cosa stia firmando.
\[
  \sigma' = \sigma \cdot b^{-1} = (m \cdot  b^e)^d \cdot b^{-1} = m^d \cdot b^{ed} \cdot b^{-1} = 
  m^d \cdot b \cdot b^{-1} = m^d
\]
Vorremmo migliorare il sistema, in modo tale che $B$ firmi comunque alla cieca, ma che abbia la garanzia 
che sia un messaggio costruito in maniera adeguata a quello che doveva effettivamente firmare. Per farlo 
abbiamo due modi:
\begin{enumerate}
  \item La chiave pubblica usata da $B$ può essere usata solo per spedire pin.
  \item Complicando il protocollo. Per farlo $A$ genera $m_1, m_2, \dots, m_l$
  differenti messaggi di comunicazione pin e tali messaggi devono essere tutti 
  identici, ma differiscono solo per il valore del pin. $A$ genera $b_1, b_2, \dots, b_l$
  blinding factor secondo il protocollo e spedisce a $B$ i messaggi $m_1 \cdot b_1^e,
  m_2 \cdot b_2^e, \dots, m_l \cdot b_l^e$. A questo punto $B$ sceglie $i \in_R \{1, \dots, l\}$,
  scegliendo quindi una lettera e comunica $b$ ad $A$, a questo punto $A$ comunica 
  $m_1, b_1, \dots, m_{i-1},b_{i-1},m_{i+1},b_{i+1}, \dots, m_l, b_l$ ad $B$,
  comunicando tutte le informazioni tranne quelle relative al messaggio $i$-esimo.
  $B$ verifica la correttezza dei dati ricevuti e se la verifica ha successo produce 
  la firma $\sigma = (m_i \cdot b_i^e)^d$, altrimenti rifiuta la firma.
\end{enumerate}
Scegliendo $l$ sufficientemente grande, la probabilità che $B$ riesca a trovare il valore
del pin si abbassa, ma la probabilità di attacco resta comunque alta, implicando quindi 
la necessità di trovare altri strumenti per contrastare gli attacchi.